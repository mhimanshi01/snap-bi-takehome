# -*- coding: utf-8 -*-
"""Untitled21.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eYSFcivrGE6gcBlFelt34UQBG8nkijqY
"""

# app.py
# Snap Finance Take-Home — Streamlit Dashboard
#
# ✅ Implemented changes:
# Row 1: Task 1 -> # Applications / # Approved / # Used (separate bordered blocks)
# Row 2: Task 2 -> Avg Approved Amount + Avg Used Amount trends over submission date
#        + Statewise Distribution map placed next to Task 2
# Row 3: Task 3 -> Store table with Approval/Completion/Conversion rates
# Row 3b: Below Task 3 table -> 3 graphs (Approval/Completion/Conversion rate trends)
# Row 4: Task 4 -> Used dollars vs Marketing spend (by campaign)
# Row 5: Task 5 -> Scatter (Approval vs Utilization by Lease Grade)
#        + A separate insight container next to Task 5 (NO "Task 6")
#
# Added: Trend granularity includes Daily / Weekly / Monthly / Quarterly
#
# Run:
#   python3 -m pip install -r requirements.txt
#   python3 -m streamlit run app.py

from __future__ import annotations

from pathlib import Path
import numpy as np
import pandas as pd
import streamlit as st
import plotly.express as px


# -----------------------------
# Page config + styling
# -----------------------------
st.set_page_config(page_title="Snap Finance — Application Performance Dashboard", layout="wide")

st.markdown(
    """
<style>
/* Border wrapper used by st.container(border=True) */
[data-testid="stVerticalBlockBorderWrapper"]{
    border: 3px solid #000 !important;
    border-radius: 0px !important;
    padding: 14px !important;
}
.block-container { padding-top: 1.2rem; }
[data-testid="stMetricLabel"] p { font-size: 0.9rem; }
h2, h3 { margin-bottom: 0.4rem; }
</style>
""",
    unsafe_allow_html=True,
)

APP_DIR = Path(__file__).parent
DEFAULT_XLSX = str(APP_DIR / "sample_datasets.xlsx")

US_STATE_ABBR = {
    "Alabama": "AL", "Alaska": "AK", "Arizona": "AZ", "Arkansas": "AR", "California": "CA",
    "Colorado": "CO", "Connecticut": "CT", "Delaware": "DE", "Florida": "FL", "Georgia": "GA",
    "Hawaii": "HI", "Idaho": "ID", "Illinois": "IL", "Indiana": "IN", "Iowa": "IA", "Kansas": "KS",
    "Kentucky": "KY", "Louisiana": "LA", "Maine": "ME", "Maryland": "MD", "Massachusetts": "MA",
    "Michigan": "MI", "Minnesota": "MN", "Mississippi": "MS", "Missouri": "MO", "Montana": "MT",
    "Nebraska": "NE", "Nevada": "NV", "New Hampshire": "NH", "New Jersey": "NJ", "New Mexico": "NM",
    "New York": "NY", "North Carolina": "NC", "North Dakota": "ND", "Ohio": "OH", "Oklahoma": "OK",
    "Oregon": "OR", "Pennsylvania": "PA", "Rhode Island": "RI", "South Carolina": "SC",
    "South Dakota": "SD", "Tennessee": "TN", "Texas": "TX", "Utah": "UT", "Vermont": "VT",
    "Virginia": "VA", "Washington": "WA", "West Virginia": "WV", "Wisconsin": "WI", "Wyoming": "WY",
    "District of Columbia": "DC",
}


# -----------------------------
# Helpers
# -----------------------------
def time_bucket(dt_series: pd.Series, granularity: str) -> pd.Series:
    dt = pd.to_datetime(dt_series, errors="coerce")

    if granularity == "Daily":
        return dt.dt.to_period("D").dt.to_timestamp()

    if granularity == "Weekly":
        return dt.dt.to_period("W").dt.start_time

    if granularity == "Monthly":
        return dt.dt.to_period("M").dt.to_timestamp()

    if granularity == "Quarterly":
        return dt.dt.to_period("Q").dt.start_time

    return dt.dt.to_period("M").dt.to_timestamp()


def safe_pct(numer: float, denom: float) -> float:
    return float(numer / denom) if denom else 0.0


def safe_div_series(numer: pd.Series, denom: pd.Series) -> pd.Series:
    denom = denom.replace(0, np.nan)
    return (numer / denom).fillna(0.0)


def normalize_state_to_abbr(series: pd.Series) -> pd.Series:
    s = series.astype(str).str.strip()
    s = s.replace(US_STATE_ABBR)
    s = s.apply(lambda x: x.upper() if isinstance(x, str) and len(x) == 2 else x)
    s = s.replace({"nan": np.nan, "None": np.nan, "": np.nan})
    return s


@st.cache_data(show_spinner=True)
def load_data(xlsx_path: str):
    customers = pd.read_excel(xlsx_path, sheet_name="customers")
    applications = pd.read_excel(xlsx_path, sheet_name="applications")
    stores = pd.read_excel(xlsx_path, sheet_name="stores")
    marketing = pd.read_excel(xlsx_path, sheet_name="marketing")

    for df in (customers, applications, stores, marketing):
        unnamed = [c for c in df.columns if str(c).startswith("Unnamed")]
        if unnamed:
            df.drop(columns=unnamed, inplace=True)

    applications["submit_date"] = pd.to_datetime(applications.get("submit_date"), errors="coerce")
    applications["approved_date"] = pd.to_datetime(applications.get("approved_date"), errors="coerce")
    stores["start_dt"] = pd.to_datetime(stores.get("start_dt"), errors="coerce")
    marketing["start_date"] = pd.to_datetime(marketing.get("start_date"), errors="coerce")
    marketing["end_date"] = pd.to_datetime(marketing.get("end_date"), errors="coerce")
    customers["DOB"] = pd.to_datetime(customers.get("DOB"), errors="coerce")

    applications["is_approved"] = applications.get("approved", False).fillna(False).astype(bool)
    applications["is_used"] = applications.get("dollars_used", 0).fillna(0).astype(float) > 0

    marketing_ren = marketing.rename(columns={"id": "campaign"})
    cust_mkt = customers.merge(marketing_ren, on="campaign", how="left", suffixes=("", "_mkt"))

    apps = applications.merge(
        cust_mkt[["customer_id", "campaign", "name", "spend"]],
        on="customer_id",
        how="left",
    )

    apps = apps.merge(stores, on="store", how="left")
    return customers, applications, stores, marketing, apps


# -----------------------------
# Title
# -----------------------------
st.title("Snap Finance — Application Performance Dashboard")
st.caption("Applications → Approvals → Usage, plus amount trends and geographic distribution.")


# -----------------------------
# Sidebar controls
# -----------------------------
with st.sidebar:
    st.header("Data")
    xlsx_path = st.text_input("Path to sample_datasets.xlsx", DEFAULT_XLSX)

    try:
        customers, applications, stores, marketing, apps = load_data(xlsx_path)
    except FileNotFoundError:
        st.error(
            "File not found.\n\n"
            "Fix: Put `sample_datasets.xlsx` in the same folder as `app.py`, "
            "or paste the full path here."
        )
        st.stop()

    st.header("Filters")

    min_dt = apps["submit_date"].min()
    max_dt = apps["submit_date"].max()
    if pd.isna(min_dt) or pd.isna(max_dt):
        st.error("submit_date is missing/invalid in the dataset.")
        st.stop()

    date_range = st.date_input(
        "Submission date range",
        value=(min_dt.date(), max_dt.date()),
        min_value=min_dt.date(),
        max_value=max_dt.date(),
    )

    granularity = st.selectbox(
        "Trend granularity",
        ["Daily", "Weekly", "Monthly", "Quarterly"],
        index=1,
    )

    def opts(col: str):
        return sorted([x for x in apps[col].dropna().unique()]) if col in apps.columns else []

    states = st.multiselect("State", opts("state"), default=[])
    industries = st.multiselect("Industry", opts("industry"), default=[])
    sizes = st.multiselect("Store size", opts("size"), default=[])
    stores_sel = st.multiselect("Store", opts("store"), default=[])
    campaigns = st.multiselect("Campaign", opts("name"), default=[])

    map_theme = st.selectbox("Map theme", ["Auto", "Dark"], index=1)


# -----------------------------
# Apply filters
# -----------------------------
start_date, end_date = date_range
mask = (apps["submit_date"].dt.date >= start_date) & (apps["submit_date"].dt.date <= end_date)

if states:
    mask &= apps["state"].isin(states)
if industries:
    mask &= apps["industry"].isin(industries)
if sizes:
    mask &= apps["size"].isin(sizes)
if stores_sel:
    mask &= apps["store"].isin(stores_sel)
if campaigns:
    mask &= apps["name"].isin(campaigns)

f = apps.loc[mask].copy()
if f.empty:
    st.warning("No data matches your filters. Please widen the date range or clear filters.")
    st.stop()

f["state_abbr"] = normalize_state_to_abbr(f["state"]) if "state" in f.columns else np.nan
f["bucket"] = time_bucket(f["submit_date"], granularity)


# -----------------------------
# KPI strip
# -----------------------------
total_apps = int(len(f))
approved_apps = int(f["is_approved"].sum())
used_apps = int(f["is_used"].sum())

approval_rate_total = safe_pct(approved_apps, total_apps)
util_rate_total = safe_pct(used_apps, total_apps)

k1, k2, k3, k4, k5 = st.columns(5)
k1.metric("Applications", f"{total_apps:,}")
k2.metric("Approved", f"{approved_apps:,}", f"{approval_rate_total:.1%}")
k3.metric("Used", f"{used_apps:,}", f"{util_rate_total:.1%}")
k4.metric("Avg Approved Amount", f"${f['approved_amount'].dropna().mean():,.0f}")
k5.metric("Avg Used Amount", f"${f['dollars_used'].dropna().mean():,.0f}")

st.divider()


# =========================================================
# TASK 1 — Three separate blocks
# =========================================================
st.subheader("Task 1 — Trends (Applications, Approved, Used)")

t1 = (
    f.groupby("bucket", as_index=False)
    .agg(
        applications=("application_id", "count"),
        approved=("is_approved", "sum"),
        used=("is_used", "sum"),
    )
    .sort_values("bucket")
)

c1, c2, c3 = st.columns(3)

with c1:
    with st.container(border=True):
        st.markdown("### # of Application")
        st.metric("Total", f"{int(t1['applications'].sum()):,}")
        fig = px.line(t1, x="bucket", y="applications", markers=True)
        fig.update_layout(height=260, margin=dict(l=10, r=10, t=10, b=10))
        st.plotly_chart(fig, use_container_width=True)

with c2:
    with st.container(border=True):
        st.markdown("### # of Approved")
        st.metric("Total", f"{int(t1['approved'].sum()):,}")
        fig = px.line(t1, x="bucket", y="approved", markers=True)
        fig.update_layout(height=260, margin=dict(l=10, r=10, t=10, b=10))
        st.plotly_chart(fig, use_container_width=True)

with c3:
    with st.container(border=True):
        st.markdown("### # of Used Application")
        st.metric("Total", f"{int(t1['used'].sum()):,}")
        fig = px.line(t1, x="bucket", y="used", markers=True)
        fig.update_layout(height=260, margin=dict(l=10, r=10, t=10, b=10))
        st.plotly_chart(fig, use_container_width=True)

st.divider()


# =========================================================
# TASK 2 — Avg Approved Amount + Avg Used Amount trends + Statewise map next to it
# =========================================================
st.subheader("Task 2 — Avg Approved Amount & Avg Used Amount Trends + Statewise Distribution")

t2 = (
    f.groupby("bucket", as_index=False)
    .agg(
        avg_approved_amount=("approved_amount", "mean"),
        avg_used_amount=("dollars_used", "mean"),
    )
    .sort_values("bucket")
)

statewise = (
    f.dropna(subset=["state_abbr"])
    .groupby("state_abbr", as_index=False)
    .agg(
        applications=("application_id", "count"),
        approved=("is_approved", "sum"),
        used=("is_used", "sum"),
        total_approved_amount=("approved_amount", "sum"),
        total_used_amount=("dollars_used", "sum"),
    )
)
statewise["approval_rate"] = safe_div_series(statewise["approved"], statewise["applications"])
statewise["utilization_rate"] = safe_div_series(statewise["used"], statewise["applications"])

t2c1, t2c2, t2c3 = st.columns([1, 1, 1.2])

with t2c1:
    with st.container(border=True):
        st.markdown("### Avg Approved Amount")
        st.metric("Average", f"${f['approved_amount'].dropna().mean():,.0f}")
        fig = px.line(t2, x="bucket", y="avg_approved_amount", markers=True)
        fig.update_layout(height=260, margin=dict(l=10, r=10, t=10, b=10))
        st.plotly_chart(fig, use_container_width=True)

with t2c2:
    with st.container(border=True):
        st.markdown("### Avg Used Amount")
        st.metric("Average", f"${f['dollars_used'].dropna().mean():,.0f}")
        fig = px.line(t2, x="bucket", y="avg_used_amount", markers=True)
        fig.update_layout(height=260, margin=dict(l=10, r=10, t=10, b=10))
        st.plotly_chart(fig, use_container_width=True)

with t2c3:
    with st.container(border=True):
        st.markdown("### Statewise Distribution")

        map_mode = st.selectbox(
            "Map Metric",
            ["applications", "approved", "used", "approval_rate", "utilization_rate", "total_used_amount", "total_approved_amount"],
            index=0,
            key="map_metric_inline",
        )

        fig_map = px.choropleth(
            statewise,
            locations="state_abbr",
            locationmode="USA-states",
            color=map_mode,
            scope="usa",
            labels={map_mode: map_mode.replace("_", " ").title()},
        )
        if map_theme == "Dark":
            fig_map.update_layout(template="plotly_dark")
        fig_map.update_layout(height=300, margin=dict(l=5, r=5, t=25, b=5))
        st.plotly_chart(fig_map, use_container_width=True)

st.divider()


# =========================================================
# TASK 3 — Store metrics table (Approval/Completion/Conversion)
# =========================================================
st.subheader("Task 3 — Metrics by Store (Funnel Rates)")

by_store = (
    f.groupby("store", as_index=False)
    .agg(
        applications=("application_id", "count"),
        approved=("is_approved", "sum"),
        used=("is_used", "sum"),
        total_approved_amount=("approved_amount", "sum"),
        total_used_amount=("dollars_used", "sum"),
        avg_approved_amount=("approved_amount", "mean"),
        avg_used_amount=("dollars_used", "mean"),
        state=("state", "first"),
        industry=("industry", "first"),
        size=("size", "first"),
    )
)

by_store["approval_rate"] = by_store.apply(lambda r: safe_pct(r["approved"], r["applications"]), axis=1)
by_store["completion_rate"] = by_store.apply(lambda r: safe_pct(r["used"], r["approved"]), axis=1)
by_store["conversion_rate"] = by_store.apply(lambda r: safe_pct(r["used"], r["applications"]), axis=1)

by_store = by_store[
    [
        "store", "state", "industry", "size",
        "applications", "approved", "used",
        "approval_rate", "completion_rate", "conversion_rate",
        "total_approved_amount", "total_used_amount",
        "avg_approved_amount", "avg_used_amount",
    ]
].sort_values("applications", ascending=False)

display_store = by_store.copy()
display_store["approval_rate"] = display_store["approval_rate"].map(lambda x: f"{x:.1%}")
display_store["completion_rate"] = display_store["completion_rate"].map(lambda x: f"{x:.1%}")
display_store["conversion_rate"] = display_store["conversion_rate"].map(lambda x: f"{x:.1%}")
display_store["total_approved_amount"] = display_store["total_approved_amount"].map(lambda x: f"${x:,.0f}")
display_store["total_used_amount"] = display_store["total_used_amount"].map(lambda x: f"${x:,.0f}")
display_store["avg_approved_amount"] = display_store["avg_approved_amount"].map(lambda x: f"${x:,.0f}")
display_store["avg_used_amount"] = display_store["avg_used_amount"].map(lambda x: f"${x:,.0f}")

st.dataframe(display_store, use_container_width=True, height=460)


# =========================================================
# BELOW TASK 3 TABLE — 3 graphs (Approval/Completion/Conversion Rate trends)
# =========================================================
st.subheader("Task 3 — Funnel Rate Trends Over Time")

funnel_trends = (
    f.groupby("bucket", as_index=False)
    .agg(
        applications=("application_id", "count"),
        approved=("is_approved", "sum"),
        used=("is_used", "sum"),
    )
    .sort_values("bucket")
)

funnel_trends["approval_rate"] = safe_div_series(funnel_trends["approved"], funnel_trends["applications"])
funnel_trends["completion_rate"] = safe_div_series(funnel_trends["used"], funnel_trends["approved"])
funnel_trends["conversion_rate"] = safe_div_series(funnel_trends["used"], funnel_trends["applications"])

g1, g2, g3 = st.columns(3)

with g1:
    with st.container(border=True):
        st.markdown("### Approval Rate")
        fig = px.line(funnel_trends, x="bucket", y="approval_rate", markers=True)
        fig.update_layout(height=260, yaxis_tickformat=".0%", margin=dict(l=10, r=10, t=10, b=10))
        st.plotly_chart(fig, use_container_width=True)

with g2:
    with st.container(border=True):
        st.markdown("### Completion Rate")
        fig = px.line(funnel_trends, x="bucket", y="completion_rate", markers=True)
        fig.update_layout(height=260, yaxis_tickformat=".0%", margin=dict(l=10, r=10, t=10, b=10))
        st.plotly_chart(fig, use_container_width=True)

with g3:
    with st.container(border=True):
        st.markdown("### Conversion Rate")
        fig = px.line(funnel_trends, x="bucket", y="conversion_rate", markers=True)
        fig.update_layout(height=260, yaxis_tickformat=".0%", margin=dict(l=10, r=10, t=10, b=10))
        st.plotly_chart(fig, use_container_width=True)

st.divider()


# =========================================================
# TASK 4 — Used dollars vs Marketing spend (by campaign)
# =========================================================
st.subheader("Task 4 — Used Dollars vs Marketing Spend (by Campaign)")

mkt = (
    f.groupby("name", as_index=False)
    .agg(
        used_dollars=("dollars_used", "sum"),
        spend=("spend", "first"),
    )
)

mkt["name"] = mkt["name"].fillna("Unknown / Unmapped")
mkt["spend"] = mkt["spend"].fillna(0)

mkt_long = mkt.melt(
    id_vars=["name"],
    value_vars=["used_dollars", "spend"],
    var_name="metric",
    value_name="amount",
)

fig4 = px.bar(
    mkt_long.sort_values("amount", ascending=False),
    x="name",
    y="amount",
    color="metric",
    barmode="group",
)
fig4.update_layout(margin=dict(l=10, r=10, t=10, b=10), height=420)
fig4.update_layout(xaxis_title="Campaign", yaxis_title="Amount", xaxis={"tickangle": -30})
st.plotly_chart(fig4, use_container_width=True)

st.divider()


# =========================================================
# TASK 5 — Scatter + Insight container next to it (NO Task 6)
# =========================================================
st.subheader("Task 5 — Insight")

left5, right5 = st.columns([1.1, 0.9])

# --- Left: Lease grade scatter
with left5:
    with st.container(border=True):
        st.markdown("### Approval vs Utilization by Lease Grade")

        lease = (
            f.groupby("lease_grade", as_index=False)
            .agg(
                applications=("application_id", "count"),
                approved=("is_approved", "sum"),
                used=("is_used", "sum"),
                avg_approved_amount=("approved_amount", "mean"),
                avg_used_amount=("dollars_used", "mean"),
            )
        )

        lease["approval_rate"] = lease.apply(lambda r: safe_pct(r["approved"], r["applications"]), axis=1)
        lease["utilization_rate"] = lease.apply(lambda r: safe_pct(r["used"], r["applications"]), axis=1)

        fig5 = px.scatter(
            lease,
            x="approval_rate",
            y="utilization_rate",
            size="applications",
            text="lease_grade",
            hover_data=["applications", "avg_approved_amount", "avg_used_amount"],
        )
        fig5.update_traces(textposition="top center")
        fig5.update_layout(
            height=420,
            xaxis_tickformat=".0%",
            yaxis_tickformat=".0%",
            xaxis_title="Approval Rate",
            yaxis_title="Utilization Rate",
            margin=dict(l=10, r=10, t=10, b=10),
        )
        st.plotly_chart(fig5, use_container_width=True)

# --- Right: “Post-approval drop-off” insight (inside a separate container)
with right5:
    with st.container(border=True):
        st.markdown("### Store Post-Approval Drop-Off (Completion Rate)")

        dropoff = (
            f.groupby("store", as_index=False)
            .agg(
                applications=("application_id", "count"),
                approved=("is_approved", "sum"),
                used=("is_used", "sum"),
            )
        )

        dropoff["approval_rate"] = safe_div_series(dropoff["approved"], dropoff["applications"])
        dropoff["completion_rate"] = safe_div_series(dropoff["used"], dropoff["approved"])
        dropoff["conversion_rate"] = safe_div_series(dropoff["used"], dropoff["applications"])

        # Focus on meaningful volume (prevents tiny stores from dominating)
        dropoff = dropoff[dropoff["approved"] >= 10].copy()
        if dropoff.empty:
            st.info("Not enough approved volume in the current filters to show store drop-off (need >= 10 approved).")
        else:
            worst = dropoff.sort_values("completion_rate").head(12)

            fig_drop = px.bar(
                worst,
                x="store",
                y="completion_rate",
                hover_data=["applications", "approved", "used", "approval_rate", "conversion_rate"],
            )
            fig_drop.update_layout(
                height=420,
                yaxis_tickformat=".0%",
                xaxis_title="Store",
                yaxis_title="Completion Rate (Used / Approved)",
                margin=dict(l=10, r=10, t=10, b=10),
            )
            fig_drop.update_layout(xaxis={"tickangle": -25})
            st.plotly_chart(fig_drop, use_container_width=True)

            st.caption(
                "Completion Rate isolates **post-approval leakage**: stores that approve customers but don’t convert approvals into usage."
            )

